# chapter 05-3 HTTP 헤더와 HTTP 기반 기술
<br />
<br/>

## HTTP 헤더

**요청 시 활용되는 HTTP 헤더** 

1. **Host**
    - Host 요청을 보낼 호스트를 나타내는 헤더이다.  주로 도메인 네임으로 명시되며, 포트 번호가 포함되어 있을 수 있다.
    - ex) http://info.cern.ch/hypertext/www/theproject.html
    **⇒  Host: info.cern.ch**
2. **User-Agent**
    - User-Agent 란 웹 브라우저와 같이 HTTP  요청을 시작하는 클라이언트 측의 프로그램을 의미한다.
    - User-Agent 헤더에는 요청 메시지 생성에 관여한 클라이언트 프로그램과 관련된 다양한 정보가 명시된다.
    - 운영체제, 브라우저 종류 및 버전, 렌더링 엔진과 같은 다양한 정보가 User-Agent에 포함되어 있어서 서버 입장에서는  User-Agent 헤더를 통해 클라이언트의 접속 환경을 유추할 수 있다.
3. **Referer**
    - 개발 시 아주 유용한 헤더 중 하나로, 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시되어, 클라이언트의 유입 경로를 파악해 볼 수 있다.
    - **⇒ Referer: https://en.wikipedia.org/**
4. **Authorization**
    - 클라이언트의 인증 정보를 담는 헤더이다.
    - 인증 타입과 인증을 위한 정보가 차례로 명시된다. 인증 타입에 따라 인증 정보에 명시될 값이 달라진다.
    - **⇒ Authorization: <type> <credentials>**

**응답시 활용되는 HTTP 헤더**

1. **Server**
    - Server 헤던더는 요청을 처리하는 서버측의 소프트웨어와 관련된 정보를 명시한다.
    - **⇒ Server: Apache/2.4.1**
    - 위 헤더 예시는 Unix 운영체제에서 동작하는 아파치 HTTP 서버를 의미한다.
2. **Allow**
    - Allow 헤더는 클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용된다.
    - 상태 코드  405( Method Not Allowed)를 응답하는 메시지에서 Allow 헤더가 함께 사용된다.
3. **Retry-After**
    - 상태코드 503(Service Undavaliable), ‘현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음’ 응답과 함께 사용할 수 있는 헤더이다.
    - Retry-After 헤더는 자원응ㄹ 사용할 수 있는 날짜 혹은 시각을 나타낸다.
    - **⇒ Retry-After: Fri, 23 Aug 2024 09:00:00 GM**T : ‘2024년 8월 23일 오전 9시 이후 사용 가능하다’
    - **⇒ Retry-After: 120**  : ‘120초 이후 사용이 가능하다’
4. **Location**
    - Location 헤더는 클라이언트에게 자원의 위치를 알려주기 위해 사용되는 헤더이다.
    - 주로 리다이렉션이 발생하거나 새로운 자원이 생성되었을 때 사용된다.
5. **WWW-Authenicate**
    - 상태코드 401(Unauthorized), ‘요청한 자원에 대한 유효한 인증이 없음’ 과 함께 사용되는 헤더이다.
    - WWW-Authenicate 헤더는 자원에 접근하기 위한 인증 방식을 설명하는 헤더이다.
    - **⇒ WWW-Authenicate: Basic**

**요청과 응답 모두에서 활용되는 HTTP 헤더**

1. **Date**
    - Date는 메시지가 생성된 날짜와 시각에 관련된 정보를 담은 헤더이다. 클라이언트와 서버 모두에서 사용될 수 있다.
2. **Connection**
    - 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더이다.
    - Connection: keep-alive ⇒ 상대방에게 지속 연결을 희망함
    - Connection: close ⇒ 서버나 클라이언트가 연결 종료를 희망함
3. **Content-Length**
    - 본문의 바이트 단위 크기(길이)를 나타낸다.
4. **Content-Type, Content-Language, Content-Encoding**
    - 전송하려는 메시지 본문의 표현 방식을 설명하는 헤더이다.
    - 이 헤더들은 표현 헤더의 일종이라고도 부른다.
    - **⇒ ContentType: text/html; charset-UTF-8**

---

## 캐시

**캐시란 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술이다**. 정보의 사본을 임시로 저장하는 것 자체를 ‘캐시 한다’ 혹은 ‘캐싱 한다’라고 표현하며, 캐시된 데이터를 캐시라 부르기도 한다. 

사본을 임시로 저장해 두면 동일한 요청에 대해 캐시된 데이터를 활용할 수 있기 때문에 불필요한 대역폭 낭비를 줄일 수 있고, 더 빠르게 데이터에 접근 할 수 있다.

캐시는 웹 브라우저에 저장되어 있기도 하고, 클라이언트와 서버 사이에 중간 서버에 저장되어 있기도 하다. 

**웹 브라우저에 저장되어 있는 캐시를 개인 전용 캐시라 하고, 클라이언트와 서버 사이에 위치한 캐시를 공용 캐시라 부른다.** 

개인 전용 캐시에 대하 알아보자.

- 캐시는 원본 데이터의 사본을 임시로 저장하는 기술이기에, 캐시를 했다면 항상 캐시한 이후로 원본 데이터가 변경되는 상황에 대비를 해야한다.
- 캐시된 사본 데이터가 얼마나 최신 원본 데이터와 유사한지를 ‘캐시 신선도’라고 표현하기도 하는데, 캐시 신선도를 유지하는 가장 기본적인 방법은 ‘캐시된 데이터에 유효 기간을 설정하는 방법’ 이다. 즉, 캐시 데이터에 유효 기간을 설정하고, 기간이 만료되었다면 원본 데이터를 다시 요청하는 방식으로 캐시 신선도를 유지할 수 있다.
- 캐시할 데이터에 유효 기간을 부여하는 방법으로 응답 메시지의 Expires 헤더(날짜)와 Cache-Contral 헤더의 Max-Age 값(초)을 사용할 수 있다.
- **캐시의 유효 기간이 만료되었다면 클라이언트는 캐시된 자원이 여전히 신선한지, 여전히 최신 상태의 정보인지 재검사를 해야 한다. 만일 서버의 원본 자본이 변경되었다면 클라이언트는 새로운 자원을 응답 받아야 한다.**
    - 여기서 캐시의 선선도를 재검사하는 방법은 크게 두 가지 방법이 있다. 
    하나는 ‘날짜를 기반으로 서버에게 물어보는 방법’, 또 다른 하나는 ‘엔티티 기반으로 서버에게 물어보는 방법’이 있다.
    - **날짜를 기반으로 재검사 ⇒ 클라이언트는 If-Modified-Since 헤더를 통해 서버에게 특정 시점 이후로 원본 데이터에 변경이 있었는지 물어볼 수 있다.**  If-Modified-Since 헤더의 값으로 특정 시점 (날짜와 시각)이 명시되는데, 이 시점 이후로 원본에 변경이 있다면 새 자원을 응답하도록 서버에게 요청하는 헤더이다.
        
        서버측에서는
        
        - 요청받은 자원이 변경된 경우 ⇒ 200(ok)와 함께 새로운 자원을 반환
        - 요청받은 자원이 변경되지 않은 경우 ⇒ 메시지 본문 없는 상태 코드 304(Not Modified)를 통해 클라이언트에게 자원이 변경되지 않았음을 알림
        - 요청받은 자원이 삭제된 경우 ⇒ 404(NotFound)를 통해 자원이 존재하지 않음을 알림
        
        304(Not Modified) 상태 코드는 자원의 ‘변경 여부’뿐만 아니라 자원의 ‘마지막 변경 시점’도 클라이언트에게 알려줄 수 있다. Last-Modified 헤더는 특정 자원이 마지막으로 수정된 시점을 나타낸다. 
        
    - **엔티티 태그로 재검사 ⇒ Etag ‘자원의 버전’을 식별하기 위한 정보이다. 버전이란 ‘유의미한 변경 사항’을 의미한다.** 
    자원이 변경될 때마다 자원의 버전을 식별하는  Etag의 값이 변경된다. 이를 위해 사용하는 헤더가 바로  If-None-Match 이다.

---

## 쿠키

HTTP는 기본적으로 상태를 유지하지 않는 스테이트리스 프로토콜이다. 만약  HTTP가 스테이트리스 프로토콜이고 클라이언트의 상태를  유지하지 않는다면, 로그인 상태 유지 기능은 어떻게 구현할 수 있을까?

HTTP 쿠키를 통해 이러한 기능을 구현할 수 있다. 

**쿠키란 서버에서 생성되어 클라이언트 측에 저장되는 데이터로, 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단이다**. 서버가 클라이언트의 상태를 알 수 있게끔하는 특별한 데이터이다.

쿠키를 이루는 정보는 기본적으로 <이름, 값> 쌍의 형태를 띠고 있고, 추가로 적용 범위와 만료 기간 등 다양한 속성을 가질 수 있다.

서버는 쿠키를 생성하여 클라이언트에게 전송하고, 클라이언트는 전달받은 쿠키를 저장해 두었다가 추후 동일한 서버에 보내는 요청 메시지에 쿠키를 포함하여 전송한다. 서버는 쿠키 정보를 참고해 두 개의 요청이 같은 클라이언트에서 왔는지, 로그인 상태를 유지하고 있는 지 등을 알 수 있다.

쿠키를 이루는 정보로는 이름과 그에 대응하는 값 뿐 아니라 도메인과 경로, 유효 기간, 보안 관련 속성이 있다.

쿠키의 대표적인 한계는 보안이다. 쿠키 정보는 쉽게 노출되거나 조작될 수 있기에 HTTPS 프로토콜이 사용되는 경우에만 쿠키를 전송되도록 할 수 있다.

---

## 콘텐츠 협상과 표현

콘텐츠 협상이란, 같은 URI에 대해 가장 적합한 자원의 형태를 제공하는 매커니즘을 의미한다. 

같은 URI로 식별 가능한 HTML 문서라 해도, 영어로 요청하면 영어로 된 형태를 제공하고, 한국어로 요청하면 한국어로 된 형태를 제공하는 것이다.

이때, ‘송수신 가능한 자원의 형태’를 자원의 표현이라고 한다. 

자원에 대한 다양한 표현 중에서 클라이언트가 선호하는 표현을 반영하고자 콘텐츠 협상 관련 HTTP 헤더들이 사용된다. 주요 헤덛로는 선호하는 미디어 타입을 나타내기 위한  Accept 헤더, 선호하는 언어를 나타내기 위한 Accept-Charset 및 Accept-Encoding헤더 등이 있다.

예를들어 클라이언트가 선호하는 언어가 한국어일 경우 , Accept-Language: ko 헤더를 추가하여 서버에 요청하면 서버는 클라이언트가 선호하는 언어를 인식하여 한국어로 표현된 자원을 보내주게 된다. 

콘텐츠 협상에서 중요한 점은 선호도에 우선순위를 반영할 수 있다는 점이다. 예를 들어 클라이언트가 언어는 한국어를 가장 선호하지만, 영어를 받을 용의가 있다는 식으로 여러 선호도를 담은 요청 메시지를 보낼 수 있다. 

이러한 우선순위는 콘텐츠 협상 관련 헤더의 q값으로 표현된다, q는 Quaility Value의 약자로, 특정 표현을 얼마나 선호하는지를 나타내며, 생략되었을 때는 1을 의미하고, 범위는 0부터 1까지이다. 값이 클수록 우선 순위는 높다.
