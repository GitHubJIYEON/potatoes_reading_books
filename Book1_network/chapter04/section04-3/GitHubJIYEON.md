# 오류 제어: 재전송 기법

TCP는 재전송을 기반으로 다양한 **오류를 제어**하고, **흐름 제어**를 통해 처리할 수 있을 만큼의 데이터만을 주고받으며, 혼잡 제어를 통해 네트워크가 혼잡한 정도에 따라 전송량을 조절합니다.

### 오류 검출과 재전송

신뢰성을 위해 오류 제어할 수 있어여 하고 TCP는 잘못된 세그먼트를 재전송하는 방법을 사용함
TCP 세그먼트에는 오류 검출을 위한 체크섬 필드가 있지만 세그먼트의 훼손 여부만 나타낼 뿐,

체크섬 값이 잘못되었다면 호스트는 해당 패킷을 읽지 않고 폐기함, 체크섬을 이용한다고 해도 송신 호스트가 세그먼트 전송 과정에 문제가 있다는 것을 인지할 수는 없음

TCP가 신뢰성을 제대로 보장하려면?

1. 우선 송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지할 수 있어야 함
2. 오류를 감지하게 되면 (세그먼트가 잘못 전송되었음을 알게 되면) 해당 세그먼트를 재전송할 수 있어야 함

**첫째, 중복되 ACK 세그먼트를 수신했을 때**

TCP는 중복된 ACK세그먼트를 수신했을 때 오류가 생겼음을 감지

-   만일 수신 호스트 측이 받은 세그먼트의 순서 번호 중에서 일부가 누락되었다면 중복된 ACK세그먼트를 전송
-   호스트 B가 n+1번 ACK 세그먼트를 반복해서 전송함

**둘째, 타임아웃이 발생했을 때**

TCP는 타임아웃이 발생하면 문제가 생겼음을 인지함

-   TCP세그먼트를 송신하는 호스트는 모두 **재전송 타이머**라는 값을 유지
-   타이머의 카운트다운이 끝난 상황(정해진 시간이 끝난 상황) **타임아웃** 이라고 함
-   세그먼트를 받지 못하면 상대 호스트에게 정상적으로 도착하지 않았다고 간주하여 세그먼트를 재전송함

### ARQ: 재전송 기법

수신 호스트의 답변(ACK)과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식을 ARQ (Automatic Repeat Request 자동 재전송 요구)
대표적 세 가지 방식 : Stop-and-Wait ARQ, Go-Back-N ARQ, Selecteive Repeat ARQ

**Stop-and-Wait ARQ**

-   제대로 전달했음을 확인하기 전까지는 새로운 메시지를 보내지 않는 방식
-   메시지를 송신하고, 이에 확인 응답을 받고, 다시 메시지를 송신하고, 이에 대한 확인 응답을 받는 것을 반복함
-   단순하지만, 높은 신뢰성을 보장하는 방식
-   네트워크의 이용 효율이 낮아지고 이는 성능 저하로 이어질 수 있음

**Go-Back-N ARQ**

-   연속해서 메시지를 전송할 수 있는 기술 **파이프라이닝**, 파이프라이닝 기반
-   도중에 잘못 전송된 세그먼트가 있는 경우 해당 세그먼트부터 다시 전송하는 방식
-   세그먼트가 전송 과정에서 유실되었다면, 수신 호스트는 그 외 모든 세그먼트를 올바르게 수신했다 해도 이를 폐기함
-   Go-Back-N ARQ 에서 순서 번호 n번에 대한 ACK세그먼트는 ‘n번만의’ 확인응답이 아니라 ‘n번까지의’ 확인 응답이라고 볼 수 있음
    ⇒ **누적 확인 응답**(CACK: Cumulative Acknowledgment) 이라고 함
-   한 세그먼트에만 문제가 발생해도 그 후의 모든 세그먼트를 다시 재전송해야 한다는 단점

**Selecteive Repeat ARQ**

-   파이프라이닝 기반
-   선택적으로 재전송하는 방법
-   수신 호스트 측에서 제대로 전송받은 각각의 패킷들에 대해 ACK세그먼트를 보내는 방식
-   **개별 확인 응답**(Selective Acknowledgment)
-   송신 호스트는 올바르게 수신받지 못한 ACK 세그먼트가 있는지 검사하고, 응답받지 못한 세그먼트가 존재한다면 해당 세그먼트를 재전송함
-   오늘날 대부분의 호소트는 TCP통신에서 Selective Repeat ARQ를 지원함 (없으면 Go-Back-M ARQ 방식으로 동작함)

### 흐름 제어: 슬라이딩 윈도우

호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에 한계가 있기에 프이프라이닝 기반의 Go-Back-N ARQ 와 Selective Repeat ARQ가 정상적으로 동작하려면 **흐름 제어** 고려해야 함

**흐름 제어**란 \*\*\*\*송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는 것을 의미

**수신 버퍼**: 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간
흐름 제어를 고려하지 않고 수신 버퍼의 크기보다 많은 데이터를 전송하면 일부 세그먼트가 처리되지 못할 수 도 있음
저장 가능한 공간보다 더 많은 데이터를 저장할 수 없기에

**버퍼 오버플로**: 버퍼가 넘치는 이런 문제 상황

**윈도우**

-   송신 호스트가 파이프라이닝할 수 있는 최대량을 의미, 윈도우의 크기만큼 확인 응답을 받지 않고도 한 번에 전송 가능하다는 의미
-   윈도우는 수신 호스트가 알려 주는 수신 측 윈도우를 토대로 알 수 있는 정보
-   수신 호스트는 TCP 헤더(윈도우 필드)를 통해 송신 호스트에게 자신이 받아들이고자 하는 데이터의 양을 알리게 됨, 송신 호스트는 이 정보를 바탕으로 수신 호스트의 처리 속도와 발맞춰 균일한 속도로 세그먼트를 전송하는 것

**슬라이딩 윈도우**: 파이프라이닝 과정에서 송수신 윈도우는 점차 오른쪽으로 미끄러지듯 움직이게 되어 TCP의 흐름 제어를 슬라이딩 윈도우 라고 불림

### 혼잡 제어

혼잡: 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황을 의미
TCP의 혼잡 제어: 혼잡 제어를 수행하는 송신 호스트는 네트워크 혼잡도를 판단하고 혼잡도 정도에 맞춰 유동적으로 전송량을 조절하며 전송함

**혼잡 윈도우 크기**:혼잡 제어 알고리즘을 통해 결정할 수 있음(혼잡 제어를 수행하는 일련의 방법)

**AIMD** (Additibe Increase/Multiplicative Decrease)

-   합으로 증가, 곱으로 감소
-   혼잡이 감지되지 않는다면 혼잡 윈도우를 RTT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘
-   톱니 모양으로 변화한다는 특징이 있음

더 정교하게 만들 혼잡 제어 알고리즘

1.  느린 시작 알고리즘
    혼잡 윈도우를 1부터 시작해 문제없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식
    혼잡 윈도우의 지수적인 증가를 활용해 초기 전송 속도를 어느 정도 빠르게 확보할 수 있음
    느린 시작 임계치: 혼잡 윈도우 값이 계속 증가하다가 느린 시작 임계치 이상이 되거나, 타임아웃이 발생, 세 번의 중복된 ACK 세그먼트가 발생하여 혼잡이 감지되면 3가지 중 하나 선택
        | 상황분류 | 방법 |
        | --- | --- |
        | 타임아웃 발생 | 혼잡 윈도우 값ㅇ르 1로, 느린 시작 임계치를 혼잡이 감지되었을 시점의 혼잡 윈도우 값의 절반으로 초기화한 뒤 느린 시작 재개 |
        | 혼잡 윈도우 ≥ 느린 시작 임계치 | 느린 시작 종료, 혼잡 윈도우를 절반으로 초기화한 뒤 혼잡 회피 수행 |
        | 세 번의 중복 ACK발생 | (빠른 재전송 후) 빠른 회복 수행 |
2.  혼잡 회피 알고리즘
    RTT마다 혼잡 윈도우를 1MSS씩 증가시키는 알고리즘
    혼잡 윈도우 크기를 선형적으로 증가시키는 것을 볼 수 있음
    느린 시작 임계치를 넘어선 시점부터는 혼자빙 발생할 우려가 있으니 조심해서 혼잡 윈도우를 증가시키는 방식
    타임아웃이 발생한 세그먼트나 세번의 중복 ACK 세그먼트가 발생한 세그먼트는 재전송함
3.  빠른 회복 알고리즘
    세 번의 중복 ACK세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알
    빠르게 전송률을 회복하기 위한 알고리즘
    빠른 회복 도중이라도 타임아웃이 발생하면 혼잡 윈도우 크기는 1로, 느린 시작 임계치는 혼잡이 감지된 시점의 절반으로 떨어뜨린 후 다시 느린 시작을 수행함

### [좀 더 알아보기] ECN: 명시적 혼잡 알림

명시적 혼잡 알림 (ECN)
: 최근 혼잡을 회피하기 위해 네트워크 중간 장치(주로 라우터)의 도움을 받는 방법

ECN은 선택적인 기능이기에 이를 지원하는 호스트가 있고, 지원하지 않는 호스트가 있음
ECN을 지원하는 호스트가 TCP/IP프로토콜로 정보를 주고받을 때, IP헤더와 TCP헤더에 ECN관련 필드가 추가됨
ECN을 이용하지 않고 송신 호스트만 혼잡 제어를 수행할 경우 타임아웃, 중복된 ACK세그먼트 수신과 같은 문제가 발생한 이후에야 혼잡 제어가 수행됨
하지만 ECN을 이용하면 수신 호스트의 ACK세그먼트를 통해 더 빠르게 혼잡을 감지할 수 있고, 이는 일반적으로 세 번의 중복된 ACK세그먼트 수신 이후나 타임아웃 발생 후에 혼잡을 제어하는 방식에 비해 더 빠름
